<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyperliquid Portfolio Tracker</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            min-height: 100vh;
            padding: 20px;
            color: #1a1a1a;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1100px; /* Increased from 900px to allow more space */
            margin: 0 auto;
            background: #ffffff;
            padding: 40px 20px;
        }
        
        h1 {
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 10px; /* Reduced margin */
            font-size: 42px;
            font-weight: 600;
            letter-spacing: -0.5px;
            font-family: 'Press Start 2P';
        }

        /* Static subheading styles */
        .subheading {
            text-align: center;
            color: #6b7280;
            margin-bottom: 40px;
            font-size: 16px;
            font-weight: normal;
        }
        
        .input-section {
            background: #f8f9fa;
            padding: 24px;
            border-radius: 8px;
            margin-bottom: 30px;
            border: 1px solid #e9ecef;
        }
        
        .dex-selector {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }
        
        .dex-option {
            padding: 12px 20px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: #ffffff;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            text-align: center;
            flex: 1;
            max-width: 200px;
        }
        
        .dex-option.active {
            background: #1a1a1a;
            color: white;
            border-color: #1a1a1a;
        }
        
        .input-group {
            display: grid;
            grid-template-columns: 2fr 1fr auto;
            gap: 15px;
            align-items: end;
            margin-bottom: 15px;
        }
        
        .input-panel {
            display: none;
        }
        
        .input-panel.active {
            display: block;
        }
        
        label {
            font-weight: 500;
            color: #4a4a4a;
            margin-bottom: 6px;
            display: block;
            font-size: 14px;
        }
        
        input, select {
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 15px;
            transition: border-color 0.2s ease;
            background: #ffffff;
            font-family: inherit;
            width: 100%;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #1a1a1a;
        }
        
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            white-space: nowrap;
        }
        
        .btn-primary {
            background: #1a1a1a;
            color: white;
        }
        
        .btn-primary:hover {
            background: #333333;
        }
        
        .btn-secondary {
            background: #f3f4f6;
            color: #4a4a4a;
            border: 1px solid #d1d5db;
        }
        
        .btn-secondary:hover {
            background: #e5e7eb;
            color: #1a1a1a;
        }
        
        /* Updated styles for centering control buttons */
        .controls {
            display: flex;
            justify-content: center; /* Center buttons horizontally */
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .portfolio-table {
            background: white;
            border-radius: 8px;
            overflow-x: auto; 
            overflow-y: visible;
            border: 1px solid #e5e7eb;
            margin-bottom: 20px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed; /* Added to control column widths */
        }
        
        th {
            background: #f9fafb;
            color: #374151;
            padding: 16px;
            text-align: left;
            font-weight: 500;
            font-size: 14px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        /* Define specific column widths */
        th:nth-child(1) {
            width: 15%; /* Asset name column - increased width */
        }
        
        th:nth-child(2) {
            width: 12%; /* Quantity column */
        }
        
        th:nth-child(3) {
            width: 12%; /* Price column */
        }
        
        th:nth-child(4) {
            width: 12%; /* Value column */
        }
        
        th:nth-child(5) {
            width: 10%; /* Allocation column */
        }
        
        th:nth-child(6) {
            width: 14%; /* Last updated column */
        }
        
        th:nth-child(7) {
            width: 15%; /* Actions column */
        }
        
        td {
            padding: 16px;
            border-bottom: 1px solid #f3f4f6;
            font-size: 14px;
            word-wrap: break-word; /* Allow long words to break */
            overflow-wrap: break-word; /* Modern browsers */
        }
        
        /* Asset name cell specific styling */
        td:first-child {
            max-width: 0; /* Forces text truncation to work with ellipsis */
        }
        
        /* Asset name wrapper for better control */
        .asset-name {
            display: flex;
            align-items: center;
        }
        
        .asset-name strong {
            text-overflow: ellipsis; /* Add ellipsis for very long names */
            overflow: hidden;
            white-space: nowrap;
        }
        
        /* Source indicator styling */
        .source-indicator {
            font-size: 11px;
            color: #6b7280;
            margin-left: 5px;
            white-space: nowrap; /* Prevent wrapping */
        }
        
        tr:hover {
            background: #f9fafb;
        }
        
        .price {
            font-weight: 500;
            color: #059669;
        }
        
        .value {
            font-weight: 500;
            color: #1a1a1a;
        }
        
        .loading {
            text-align: center;
            padding: 40px 20px;
            color: #6b7280;
            font-style: normal;
        }
        
        .error {
            background: #fef2f2;
            color: #dc2626;
            padding: 12px 16px;
            border-radius: 6px;
            margin: 10px 0;
            border: 1px solid #fecaca;
            font-size: 14px;
        }
        
        .success {
            background: #f0fdf4;
            color: #166534;
            padding: 12px 16px;
            border-radius: 6px;
            margin: 10px 0;
            border: 1px solid #bbf7d0;
            font-size: 14px;
        }
        
        .total-value {
            background: #f9fafb;
            color: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
            font-weight: 500;
            border: 1px solid #e5e7eb;
        }
        
        /* Updated styles for centering chart container content */
        .chart-container {
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items horizontally */
            margin: 0 auto 30px auto; /* Center the entire container */
            background: #f9fafb;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e5e7eb;
            max-width: 600px; /* Limit width for better centering */
        }
        
        .chart-title {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 15px;
            color: #374151;
            text-align: center; /* Ensure title text is centered */
            width: 100%;
        }
        
        .pie-chart {
            position: relative;
            width: 250px;
            height: 250px;
            margin: 0 auto 20px auto; /* Center the pie chart */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .pie-chart svg {
            display: block; /* Remove any inline spacing */
            margin: 0 auto; /* Center the SVG */
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
            width: 100%;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border-radius: 2px;
        }
        
        .history-section {
            margin-top: 30px;
        }
        
        .history-title {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 15px;
            color: #374151;
        }
        
        .edit-quantity {
            display: flex;
            gap: 5px;
        }
        
        .edit-quantity input {
            width: 80px;
            padding: 5px;
            font-size: 12px;
        }
        
        .edit-quantity button {
            padding: 5px;
            font-size: 12px;
        }
        
        /* Tooltip for long asset names */
        .asset-tooltip {
            position: relative;
            display: inline-block;
        }
        
        .asset-tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        .tooltip-text {
            visibility: hidden;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: nowrap;
        }
        
        @media (max-width: 768px) {
            .input-group {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: center; /* Center buttons vertically on small screens */
            }
            
            table {
                font-size: 14px;
                table-layout: auto; /* Allow table to adjust on mobile */
            }
            
            th, td {
                padding: 8px;
            }
            
            /* Reset column widths for mobile */
            th:nth-child(n) {
                width: auto;
            }
            
            .pie-chart {
                width: 200px;
                height: 200px;
            }
            
            .dex-selector {
                flex-direction: column;
                align-items: center;
            }
            
            .dex-option {
                width: 100%;
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>HYPORT</h1>
        
        <!-- Static subheading (replace with your desired text) -->
        <h2 class="subheading">
            Free, fast, and private â€” real-time crypto portfolio tracking in a single HTML file.<br>
        No signups, no subscriptions, no fluff. just your portfolio on your browser.</h2>
        
        <div class="input-section">
            <!-- DEX Selector -->
            <div class="dex-selector">
                <div class="dex-option active" id="hyperliquid-option" onclick="selectDex('hyperliquid')">Hyperliquid</div>
                <div class="dex-option" id="dexscreener-option" onclick="selectDex('dexscreener')">DexScreener</div>
            </div>
            
            <!-- Hyperliquid Input Panel -->
            <div class="input-panel active" id="hyperliquid-panel">
                <div class="input-group">
                    <div>
                        <label for="assetSelect">Asset</label>
                        <select id="assetSelect">
                            <option value="">Select Asset</option>
                        </select>
                    </div>
                    <div>
                        <label for="quantityInput">Quantity</label>
                        <input type="number" id="quantityInput" placeholder="0.00" step="0.001">
                    </div>
                    <div>
                        <button class="btn btn-primary" onclick="addAsset()">Add Asset</button>
                    </div>
                </div>
            </div>
            
            <!-- DexScreener Input Panel -->
            <div class="input-panel" id="dexscreener-panel">
                <div class="input-group">
                    <div>
                        <label for="dexScreenerLink">DexScreener Link</label>
                        <input type="text" id="dexScreenerLink" placeholder="https://dexscreener.com/solana/...">
                    </div>
                    <div>
                        <label for="dexQuantityInput">Quantity</label>
                        <input type="number" id="dexQuantityInput" placeholder="0.00" step="0.001">
                    </div>
                    <div>
                        <button class="btn btn-primary" onclick="addAsset()">Add Asset</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button class="btn btn-primary" onclick="refreshPrices()">Refresh Prices</button>
            <button class="btn btn-secondary" onclick="downloadHistoryCSV()">Download History CSV</button>
            <button class="btn btn-secondary" onclick="clearPortfolio()">Clear All</button>
        </div>
        
        <div id="totalValue" class="total-value" style="display: none;">
            Total Portfolio Value: $<span id="totalAmount">0.00</span>
        </div>
        
        <div id="chartContainer" class="chart-container" style="display: none;">
            <div class="chart-title">Portfolio Allocation</div>
            <div id="pieChart" class="pie-chart"></div>
            <div id="chartLegend" class="legend"></div>
        </div>
        
        <div id="messages"></div>
        
        <div class="portfolio-table">
            <table>
                <thead>
                    <tr>
                        <th>Asset</th>
                        <th>Quantity</th>
                        <th>Current Price</th>
                        <th>Value (USD)</th>
                        <th>Allocation %</th>
                        <th>Last Updated</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="portfolioBody">
                    <tr>
                        <td colspan="7" class="loading">Add assets to start tracking your portfolio</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Portfolio data stored in memory
        let portfolio = [];
        let priceCache = {};
        let portfolioHistory = [];
        let priceUpdateInterval;
        let tokenMapping = {};
        let dexScreenerCache = {};
        let currentDex = 'hyperliquid'; // Default to Hyperliquid
        let spotTokensData = {}; // Store spot token data for name mapping
        
        // Colors for pie chart
        const chartColors = [
            '#3366CC', '#DC3912', '#FF9900', '#109618', '#990099', 
            '#0099C6', '#DD4477', '#66AA00', '#B82E2E', '#316395', 
            '#994499', '#22AA99', '#AAAA11', '#6633CC', '#E67300', 
            '#8B0707', '#329262', '#5574A6', '#3B3EAC'
        ];

        // Load portfolio from localStorage on page load
        window.onload = function() {
            loadPortfolio();
            loadAvailableAssets();
            startAutoRefresh();
        };
        
        // Switch between DEX options
        function selectDex(dex) {
            currentDex = dex;
            
            // Update UI
            document.getElementById('hyperliquid-option').classList.toggle('active', dex === 'hyperliquid');
            document.getElementById('dexscreener-option').classList.toggle('active', dex === 'dexscreener');
            
            document.getElementById('hyperliquid-panel').classList.toggle('active', dex === 'hyperliquid');
            document.getElementById('dexscreener-panel').classList.toggle('active', dex === 'dexscreener');
        }
        
        // Start auto-refresh of prices
        function startAutoRefresh() {
            // Clear any existing interval
            if (priceUpdateInterval) {
                clearInterval(priceUpdateInterval);
            }
            
            // Set interval to refresh prices every 60 seconds
            priceUpdateInterval = setInterval(() => {
                if (portfolio.length > 0) {
                    refreshPrices(true); // silent refresh
                }
            }, 60000); // 60 seconds
        }

        // Save portfolio to localStorage
        function savePortfolio() {
            localStorage.setItem('hyperliquid_portfolio', JSON.stringify(portfolio));
            localStorage.setItem('hyperliquid_portfolio_history', JSON.stringify(portfolioHistory));
            localStorage.setItem('dexscreener_cache', JSON.stringify(dexScreenerCache));
        }

        // Load portfolio from localStorage
        function loadPortfolio() {
            const saved = localStorage.getItem('hyperliquid_portfolio');
            const savedHistory = localStorage.getItem('hyperliquid_portfolio_history');
            const savedDexCache = localStorage.getItem('dexscreener_cache');
            
            if (saved) {
                portfolio = JSON.parse(saved);
                updatePortfolioDisplay();
            }
            
            if (savedHistory) {
                portfolioHistory = JSON.parse(savedHistory);
            }
            
            if (savedDexCache) {
                dexScreenerCache = JSON.parse(savedDexCache);
            }
        }

        // Load available assets from Hyperliquid
        async function loadAvailableAssets() {
            try {
                // First, get spot metadata for proper token naming
                try {
                    const metaResponse = await fetch('https://api.hyperliquid.xyz/info', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({type: 'spotMeta'})
                    });
                    
                    const spotMeta = await metaResponse.json();
                    spotTokensData = spotMeta; // Store the full spot metadata for later use
                    
                    // Create token mapping
                    tokenMapping = {};
                    
                    // Process spot assets following the SDK logic
                    for (const spotInfo of spotMeta.universe) {
                        const name = spotInfo.name;
                        const index = spotInfo.index;
                        
                        // For tokens with @ prefix, use BASE/QUOTE format from tokens
                        let displayName;
                        
                        if (name.startsWith('@')) {
                            // Extract base and quote tokens
                            const [base, quote] = spotInfo.tokens;
                            const baseInfo = spotMeta.tokens[base];
                            const quoteInfo = spotMeta.tokens[quote];
                            
                            // Create display name, removing /USDC if it's the quote
                            if (quoteInfo && quoteInfo.name === 'USDC') {
                                displayName = baseInfo.name;
                            } else {
                                displayName = `${baseInfo.name}/${quoteInfo.name}`;
                            }
                        } else {
                            // For tokens with proper names, use the name directly
                            displayName = name;
                        }
                        
                        tokenMapping[name] = {
                            name: name,
                            display: displayName,
                            index: index,
                            isSpot: true,
                            tokens: spotInfo.tokens
                        };
                    }
                } catch (metaError) {
                    console.error('Error loading spot token metadata:', metaError);
                }
                
                // Get all available assets with prices
                const response = await fetch('https://api.hyperliquid.xyz/info', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({type: 'allMids'})
                });
                
                const data = await response.json();
                const select = document.getElementById('assetSelect');
                
                // Clear existing options except the first one
                while (select.children.length > 1) {
                    select.removeChild(select.lastChild);
                }
                
                // Add USD as the first option
                const usdOption = document.createElement('option');
                usdOption.value = 'USD';
                usdOption.textContent = 'USD';
                select.appendChild(usdOption);
                
                // Prepare assets for sorting and deduplication
                const assetsMap = new Map();
                
                // Process all assets from allMids
                Object.keys(data).forEach(asset => {
                    let displayName = asset;
                    if (tokenMapping[asset]) {
                        displayName = tokenMapping[asset].display;
                    }
                    
                    // Prioritize perpetual asset value if display name is duplicated
                    if (!assetsMap.has(displayName) || !asset.startsWith('@')) {
                        assetsMap.set(displayName, { value: asset, display: displayName });
                    }
                });
                
                // Convert map values to array
                const assets = Array.from(assetsMap.values());
                
                // Sort assets by display name, but prioritize common tokens
                const priorityTokens = ['BTC', 'ETH', 'SOL', 'HYPE', 'PURR'];
                assets.sort((a, b) => {
                    const aIsPriority = priorityTokens.includes(a.display);
                    const bIsPriority = priorityTokens.includes(b.display);
                    
                    if (aIsPriority && !bIsPriority) return -1;
                    if (!aIsPriority && bIsPriority) return 1;
                    if (aIsPriority && bIsPriority) {
                        return priorityTokens.indexOf(a.display) - priorityTokens.indexOf(b.display);
                    }
                    
                    return a.display.localeCompare(b.display);
                });
                
                // Add all unique assets to dropdown
                assets.forEach(asset => {
                    const option = document.createElement('option');
                    option.value = asset.value; // Use the prioritized value (perp over spot)
                    option.textContent = asset.display;
                    select.appendChild(option);
                });
                
            } catch (error) {
                showMessage('Could not load available assets. Using default list.', 'error');
                console.error('Error loading assets:', error);
                
                // Ensure USD is still available even if API fails
                const select = document.getElementById('assetSelect');
                if (select.children.length <= 1) {
                    const usdOption = document.createElement('option');
                    usdOption.value = 'USD';
                    usdOption.textContent = 'USD';
                    select.appendChild(usdOption);
                }
            }
        }

        // Get display name for an asset
        function getDisplayName(asset) {
            if (asset === 'USD') {
                return 'USD';
            }
            
            // Check if we have this asset in our token mapping
            if (tokenMapping[asset]) {
                return tokenMapping[asset].display;
            }
            
            // If it's a spot asset with @ prefix but not in our mapping yet
            if (asset.startsWith('@') && spotTokensData && spotTokensData.universe) {
                // Find the spot info for this asset
                const spotInfo = spotTokensData.universe.find(token => token.name === asset);
                
                if (spotInfo && spotInfo.tokens && spotInfo.tokens.length >= 2) {
                    const [base, quote] = spotInfo.tokens;
                    const baseInfo = spotTokensData.tokens[base];
                    const quoteInfo = spotTokensData.tokens[quote];
                    
                    if (baseInfo && quoteInfo) {
                        // Create display name, removing /USDC if it's the quote
                        let displayName;
                        if (quoteInfo.name === 'USDC') {
                            displayName = baseInfo.name;
                        } else {
                            displayName = `${baseInfo.name}/${quoteInfo.name}`;
                        }
                        
                        // Cache the display name
                        tokenMapping[asset] = {
                            name: asset,
                            display: displayName,
                            isSpot: true,
                            tokens: spotInfo.tokens
                        };
                        return displayName;
                    }
                }
            }
            
            // Fallback to the original asset name
            return asset;
        }

        // Parse DexScreener link to extract chain and pair ID
        function parseDexScreenerLink(link) {
            const regex = /dexscreener\.com\/([^/]+)\/([^/\s]+)/;
            const match = link.match(regex);
            
            if (!match) {
                throw new Error(`Invalid DexScreener link format: ${link}`);
            }
            
            return {
                chainId: match[1],
                pairId: match[2]
            };
        }

        // Fetch pair information from DexScreener API
        async function fetchPairInfo(chainId, pairId) {
            try {
                const url = `https://api.dexscreener.com/latest/dex/pairs/${chainId}/${pairId}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error fetching pair info:', error);
                throw error;
            }
        }

        // Get asset information from a DexScreener link with caching
        async function getAssetFromDexScreenerLink(dexScreenerLink) {
            // Check cache first (with 5 minute expiration)
            if (dexScreenerCache[dexScreenerLink]) {
                const cachedData = dexScreenerCache[dexScreenerLink];
                const cacheAge = Date.now() - cachedData.timestamp;
                
                // Return cached data if it's less than 5 minutes old
                if (cacheAge < 5 * 60 * 1000) {
                    return cachedData.data;
                }
            }
            
            try {
                // Parse the link
                const { chainId, pairId } = parseDexScreenerLink(dexScreenerLink);
                
                // Fetch data from API
                const pairData = await fetchPairInfo(chainId, pairId);
                
                if (!pairData || !pairData.pairs || pairData.pairs.length === 0) {
                    throw new Error('No pair data found');
                }
                
                // Get the first pair
                const pair = pairData.pairs[0];
                
                // Extract relevant asset information
                const assetInfo = {
                    name: pair.baseToken.name,
                    symbol: pair.baseToken.symbol,
                    address: pair.baseToken.address,
                    chain: chainId,
                    priceUsd: parseFloat(pair.priceUsd || 0),
                    priceNative: parseFloat(pair.priceNative || 0),
                    liquidityUsd: pair.liquidity?.usd,
                    pairAddress: pair.pairAddress,
                    dexId: pair.dexId,
                    dexScreenerLink: dexScreenerLink,
                    updatedAt: new Date().toISOString()
                };
                
                // Cache the result
                dexScreenerCache[dexScreenerLink] = {
                    data: assetInfo,
                    timestamp: Date.now()
                };
                
                // Save cache to localStorage
                localStorage.setItem('dexscreener_cache', JSON.stringify(dexScreenerCache));
                
                return assetInfo;
            } catch (error) {
                console.error('Error getting asset from DexScreener link:', error);
                throw error;
            }
        }

        // Unified add asset function
        async function addAsset() {
            if (currentDex === 'hyperliquid') {
                addHyperliquidAsset();
            } else {
                await addDexScreenerAsset();
            }
        }

        // Add Hyperliquid asset
        function addHyperliquidAsset() {
            const asset = document.getElementById('assetSelect').value;
            const quantity = parseFloat(document.getElementById('quantityInput').value);
            
            if (!asset || !quantity || quantity <= 0) {
                showMessage('Please select an asset and enter a valid quantity', 'error');
                return;
            }
            
            // Check if asset already exists
            const existingIndex = portfolio.findIndex(item => item.asset === asset && !item.dexScreenerLink);
            
            if (existingIndex >= 0) {
                // Update existing asset
                portfolio[existingIndex].quantity = quantity;
                portfolio[existingIndex].lastUpdated = new Date().toLocaleString();
                showMessage(`Updated ${getDisplayName(asset)} in portfolio`, 'success');
            } else {
                // Add new asset
                portfolio.push({
                    asset: asset,
                    quantity: quantity,
                    price: asset === 'USD' ? 1 : 0, // USD always has price of $1
                    value: asset === 'USD' ? quantity : 0, // USD value is always equal to quantity
                    allocation: 0,
                    source: 'hyperliquid',
                    lastUpdated: new Date().toLocaleString()
                });
                showMessage(`Added ${getDisplayName(asset)} to portfolio`, 'success');
            }
            
            // Record the change in history
            portfolioHistory.push({
                timestamp: new Date().toISOString(),
                action: existingIndex >= 0 ? 'UPDATE' : 'ADD',
                asset: asset,
                displayAsset: getDisplayName(asset),
                quantity: quantity,
                price: asset === 'USD' ? 1 : 0,
                value: asset === 'USD' ? quantity : 0,
                source: 'hyperliquid'
            });
            
            // Clear inputs
            document.getElementById('assetSelect').value = '';
            document.getElementById('quantityInput').value = '';
            
            savePortfolio();
            refreshPrices();
        }

        // Add DexScreener asset
        async function addDexScreenerAsset() {
            const dexScreenerLink = document.getElementById('dexScreenerLink').value.trim();
            const quantity = parseFloat(document.getElementById('dexQuantityInput').value);
            
            if (!dexScreenerLink) {
                showMessage('Please enter a valid DexScreener link', 'error');
                return;
            }
            
            if (!quantity || quantity <= 0) {
                showMessage('Please enter a valid quantity', 'error');
                return;
            }
            
            try {
                showMessage('Fetching asset information from DexScreener...', 'success');
                
                // Get asset information
                const assetInfo = await getAssetFromDexScreenerLink(dexScreenerLink);
                
                if (!assetInfo) {
                    showMessage('Failed to retrieve asset information', 'error');
                    return;
                }
                
                // Create a unique asset identifier
                const assetId = `DEX_${assetInfo.chain}_${assetInfo.symbol}`;
                
                // Check if asset already exists
                const existingIndex = portfolio.findIndex(item => 
                    item.assetId === assetId || 
                    (item.dexScreenerLink && item.dexScreenerLink === dexScreenerLink)
                );
                
                if (existingIndex >= 0) {
                    // Update existing asset
                    portfolio[existingIndex].quantity = quantity;
                    portfolio[existingIndex].price = assetInfo.priceUsd;
                    portfolio[existingIndex].value = quantity * assetInfo.priceUsd;
                    portfolio[existingIndex].lastUpdated = new Date().toLocaleString();
                    showMessage(`Updated ${assetInfo.symbol} in portfolio`, 'success');
                } else {
                    // Add new asset
                    portfolio.push({
                        assetId: assetId,
                        asset: assetInfo.symbol,
                        name: assetInfo.name,
                        quantity: quantity,
                        price: assetInfo.priceUsd,
                        value: quantity * assetInfo.priceUsd,
                        allocation: 0,
                        chain: assetInfo.chain,
                        dexScreenerLink: dexScreenerLink,
                        source: 'dexscreener',
                        lastUpdated: new Date().toLocaleString()
                    });
                    showMessage(`Added ${assetInfo.name} (${assetInfo.symbol}) to portfolio`, 'success');
                }
                
                // Record the change in history
                portfolioHistory.push({
                    timestamp: new Date().toISOString(),
                    action: existingIndex >= 0 ? 'UPDATE' : 'ADD',
                    asset: assetInfo.symbol,
                    displayAsset: assetInfo.name,
                    quantity: quantity,
                    price: assetInfo.priceUsd,
                    value: quantity * assetInfo.priceUsd,
                    source: 'dexscreener',
                    link: dexScreenerLink
                });
                
                // Clear inputs
                document.getElementById('dexScreenerLink').value = '';
                document.getElementById('dexQuantityInput').value = '';
                
                savePortfolio();
                updatePortfolioDisplay();
                updatePieChart();
                
            } catch (error) {
                showMessage(`Error: ${error.message}`, 'error');
                console.error('Error adding asset from DexScreener:', error);
            }
        }

        // Refresh prices from Hyperliquid API and DexScreener
        async function refreshPrices(silent = false) {
            if (portfolio.length === 0) {
                if (!silent) {
                    showMessage('No assets in portfolio to refresh', 'error');
                }
                return;
            }
            
            if (!silent) {
                showMessage('Refreshing prices...', 'success');
            }
            
            try {
                // First, refresh spot metadata to ensure we have the latest token information
                try {
                    const spotMetaResponse = await fetch('https://api.hyperliquid.xyz/info', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({type: 'spotMeta'})
                    });
                    
                    const spotMeta = await spotMetaResponse.json();
                    spotTokensData = spotMeta; // Update spot token data
                    
                    // Update token mapping for spot assets
                    for (const spotInfo of spotMeta.universe) {
                        const name = spotInfo.name;
                        
                        if (name.startsWith('@')) {
                            // Extract base and quote tokens
                            const [base, quote] = spotInfo.tokens;
                            const baseInfo = spotMeta.tokens[base];
                            const quoteInfo = spotMeta.tokens[quote];
                            
                            // Create display name, removing /USDC if it's the quote
                            let displayName;
                            if (quoteInfo && quoteInfo.name === 'USDC') {
                                displayName = baseInfo.name;
                            } else {
                                displayName = `${baseInfo.name}/${quoteInfo.name}`;
                            }
                            
                            // Update or add to token mapping
                            tokenMapping[name] = {
                                name: name,
                                display: displayName,
                                index: spotInfo.index,
                                isSpot: true,
                                tokens: spotInfo.tokens
                            };
                        }
                    }
                } catch (spotMetaError) {
                    console.error('Error refreshing spot metadata:', spotMetaError);
                }
                
                // Get all prices from Hyperliquid
                const response = await fetch('https://api.hyperliquid.xyz/info', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({type: 'allMids'})
                });
                
                const prices = await response.json();
                priceCache = prices;
                
                // Create an array of promises for DexScreener assets
                const dexScreenerPromises = [];
                
                // Update portfolio with new prices
                let totalValue = 0;
                let pricesUpdated = false;
                
                // First pass: update Hyperliquid prices and collect DexScreener links
                portfolio.forEach((item, index) => {
                    // Skip DexScreener assets for now
                    if (item.dexScreenerLink) {
                        dexScreenerPromises.push(
                            getAssetFromDexScreenerLink(item.dexScreenerLink)
                                .then(assetInfo => {
                                    // Update price and value
                                    const oldPrice = item.price;
                                    item.price = assetInfo.priceUsd;
                                    item.value = item.quantity * assetInfo.priceUsd;
                                    item.lastUpdated = new Date().toLocaleString();
                                    
                                    // Check if price has changed
                                    if (oldPrice !== item.price) {
                                        pricesUpdated = true;
                                    }
                                })
                                .catch(error => {
                                    console.error(`Error updating price for ${item.asset}:`, error);
                                })
                        );
                        return;
                    }
                    
                    // USD always has a fixed price of $1
                    const price = item.asset === 'USD' ? 1 : parseFloat(prices[item.asset] || 0);
                    
                    // Check if price has changed
                    if (price !== item.price) {
                        pricesUpdated = true;
                    }
                    
                    item.price = price;
                    item.value = item.quantity * price;
                    item.lastUpdated = new Date().toLocaleString();
                });
                
                // Wait for all DexScreener price updates to complete
                if (dexScreenerPromises.length > 0) {
                    await Promise.all(dexScreenerPromises);
                }
                
                // Calculate total value
                totalValue = portfolio.reduce((sum, item) => sum + item.value, 0);
                
                // Calculate allocations
                portfolio.forEach(item => {
                    item.allocation = totalValue > 0 ? (item.value / totalValue) * 100 : 0;
                });
                
                // Record portfolio snapshot in history if prices changed
                if (pricesUpdated) {
                    const timestamp = new Date().toISOString();
                    
                    // Record total portfolio value
                    portfolioHistory.push({
                        timestamp: timestamp,
                        action: 'PORTFOLIO_SNAPSHOT',
                        totalValue: totalValue
                    });
                    
                    savePortfolio();
                }
                
                updatePortfolioDisplay();
                updatePieChart();
                
                if (!silent) {
                    showMessage('Prices updated successfully!', 'success');
                }
                
            } catch (error) {
                if (!silent) {
                    showMessage('Failed to fetch prices from API', 'error');
                    console.error('API Error:', error);
                }
                
                // Even if API fails, ensure USD price is still $1
                portfolio.forEach(item => {
                    if (item.asset === 'USD') {
                        item.price = 1;
                        item.value = item.quantity;
                        item.lastUpdated = new Date().toLocaleString();
                    }
                });
                
                // Recalculate total value and allocations
                const totalValue = portfolio.reduce((sum, item) => sum + item.value, 0);
                portfolio.forEach(item => {
                    item.allocation = totalValue > 0 ? (item.value / totalValue) * 100 : 0;
                });
                
                updatePortfolioDisplay();
                updatePieChart();
            }
        }

        // Update portfolio display
        function updatePortfolioDisplay() {
            const tbody = document.getElementById('portfolioBody');
            const totalElement = document.getElementById('totalValue');
            const totalAmount = document.getElementById('totalAmount');
            const chartContainer = document.getElementById('chartContainer');
            
            if (portfolio.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="loading">Add assets to start tracking your portfolio</td></tr>';
                totalElement.style.display = 'none';
                chartContainer.style.display = 'none';
                return;
            }
            
            let totalValue = portfolio.reduce((sum, item) => sum + item.value, 0);
            
            tbody.innerHTML = portfolio.map((item, index) => {
                // Determine display name based on source
                let displayName;
                
                if (item.source === 'dexscreener') {
                    displayName = item.name || item.asset;
                } else {
                    displayName = getDisplayName(item.asset);
                }
                
                // Add source indicator
                const sourceIndicator = '';
                
                // Create asset name with tooltip for very long names
                const assetNameHtml = `
                    <div class="asset-name asset-tooltip">
                        <strong title="${displayName}">${displayName}</strong>
                        ${sourceIndicator}
                    </div>
                `;
                
                return `
                <tr>
                    <td>${assetNameHtml}</td>
                    <td>${item.quantity.toFixed(6)}</td>
                    <td class="price">$${item.price.toFixed(6)}</td>
                    <td class="value">$${item.value.toFixed(2)}</td>
                    <td>${item.allocation.toFixed(1)}%</td>
                    <td>${item.lastUpdated}</td>
                    <td>
                        <div class="edit-quantity">
                            <input type="number" id="editQuantity${index}" value="${item.quantity}" step="0.001" min="0">
                            <button class="btn btn-secondary" onclick="updateQuantity(${index})" style="padding: 5px 10px; font-size: 12px;">Update</button>
                        </div>
                        <button class="btn btn-secondary" onclick="removeAsset(${index})" style="padding: 5px 10px; font-size: 12px; margin-top: 5px;">Remove</button>
                    </td>
                </tr>
            `}).join('');
            
            totalAmount.textContent = totalValue.toFixed(2);
            totalElement.style.display = 'block';
            chartContainer.style.display = 'block';
        }

        // Update quantity of an asset
        function updateQuantity(index) {
            const quantityInput = document.getElementById(`editQuantity${index}`);
            const newQuantity = parseFloat(quantityInput.value);
            
            if (!newQuantity || newQuantity <= 0) {
                showMessage('Please enter a valid quantity', 'error');
                return;
            }
            
            const asset = portfolio[index];
            const oldQuantity = asset.quantity;
            
            // Update quantity
            asset.quantity = newQuantity;
            asset.value = asset.price * newQuantity;
            asset.lastUpdated = new Date().toLocaleString();
            
            // Determine display name for history
            let displayName;
            if (asset.source === 'dexscreener') {
                displayName = asset.name || asset.asset;
            } else {
                displayName = getDisplayName(asset.asset);
            }
            
            // Record the change in history
            portfolioHistory.push({
                timestamp: new Date().toISOString(),
                action: 'QUANTITY_CHANGE',
                asset: asset.asset,
                displayAsset: displayName,
                oldQuantity: oldQuantity,
                newQuantity: newQuantity,
                source: asset.source || 'hyperliquid'
            });
            
            // Update portfolio display
            updatePortfolioDisplay();
            updatePieChart();
            savePortfolio();
            
            showMessage(`Updated quantity of ${displayName} to ${newQuantity}`, 'success');
        }

        // Update pie chart
        function updatePieChart() {
            if (portfolio.length === 0) {
                return;
            }
            
            const pieChart = document.getElementById('pieChart');
            const legend = document.getElementById('chartLegend');
            
            // Clear previous chart and legend
            pieChart.innerHTML = '';
            legend.innerHTML = '';
            
            // Create SVG element
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', '0 0 100 100');
            pieChart.appendChild(svg);
            
            // Filter out assets with zero value
            const validAssets = portfolio.filter(item => item.value > 0);
            
            if (validAssets.length === 0) {
                return;
            }
            
            // Calculate total value
            const totalValue = validAssets.reduce((sum, item) => sum + item.value, 0);
            
            // Sort assets by value (descending)
            validAssets.sort((a, b) => b.value - a.value);
            
            // Draw pie chart
            let startAngle = 0;
            validAssets.forEach((item, index) => {
                const percentage = item.value / totalValue;
                const endAngle = startAngle + percentage * 360;
                
                // Calculate path
                const x1 = 50 + 40 * Math.cos(Math.PI * startAngle / 180);
                const y1 = 50 + 40 * Math.sin(Math.PI * startAngle / 180);
                const x2 = 50 + 40 * Math.cos(Math.PI * endAngle / 180);
                const y2 = 50 + 40 * Math.sin(Math.PI * endAngle / 180);
                
                // Create path element
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const largeArcFlag = percentage > 0.5 ? 1 : 0;
                
                path.setAttribute('d', `M 50 50 L ${x1} ${y1} A 40 40 0 ${largeArcFlag} 1 ${x2} ${y2} Z`);
                path.setAttribute('fill', chartColors[index % chartColors.length]);
                path.setAttribute('stroke', '#ffffff');
                path.setAttribute('stroke-width', '1');
                
                // Determine display name for tooltip
                let displayName;
                if (item.source === 'dexscreener') {
                    displayName = item.name || item.asset;
                } else {
                    displayName = getDisplayName(item.asset);
                }
                
                // Add tooltip
                path.setAttribute('data-asset', displayName);
                path.setAttribute('data-value', `$${item.value.toFixed(2)}`);
                path.setAttribute('data-percentage', `${(percentage * 100).toFixed(1)}%`);
                
                svg.appendChild(path);
                
                // Add to legend
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = chartColors[index % chartColors.length];
                
                const text = document.createElement('span');
                text.textContent = `${displayName} (${(percentage * 100).toFixed(1)}%)`;
                
                legendItem.appendChild(colorBox);
                legendItem.appendChild(text);
                legend.appendChild(legendItem);
                
                startAngle = endAngle;
            });
        }

        // Remove asset from portfolio
        function removeAsset(index) {
            const asset = portfolio[index];
            portfolio.splice(index, 1);
            
            // Determine display name for history
            let displayName;
            if (asset.source === 'dexscreener') {
                displayName = asset.name || asset.asset;
            } else {
                displayName = getDisplayName(asset.asset);
            }
            
            // Record the removal
            portfolioHistory.push({
                timestamp: new Date().toISOString(),
                action: 'REMOVE',
                asset: asset.asset,
                displayAsset: displayName,
                quantity: asset.quantity,
                price: asset.price,
                value: asset.value,
                source: asset.source || 'hyperliquid'
            });
            
            updatePortfolioDisplay();
            updatePieChart();
            savePortfolio();
            showMessage(`Removed ${displayName} from portfolio`, 'success');
        }

        // Clear entire portfolio
        function clearPortfolio() {
            if (confirm('Are you sure you want to clear the entire portfolio?')) {
                // Record the clear action
                portfolioHistory.push({
                    timestamp: new Date().toISOString(),
                    action: 'CLEAR_PORTFOLIO',
                    portfolioSize: portfolio.length
                });
                
                portfolio = [];
                updatePortfolioDisplay();
                updatePieChart();
                savePortfolio();
                showMessage('Portfolio cleared', 'success');
            }
        }

        // Download portfolio history as CSV
        function downloadHistoryCSV() {
            if (portfolioHistory.length === 0) {
                showMessage('No history to download', 'error');
                return;
            }
            
            // Create CSV content
            let csvContent = 'Timestamp,Action,Asset,Quantity,Price,Value,Source\n';
            
            portfolioHistory.forEach(entry => {
                let row = '';
                
                // Format timestamp
                const date = new Date(entry.timestamp);
                const formattedDate = date.toLocaleString();
                
                row += `"${formattedDate}",`;
                row += `"${entry.action}",`;
                
                if (entry.action === 'PORTFOLIO_SNAPSHOT') {
                    row += `"TOTAL",,,"${entry.totalValue.toFixed(2)}",`;
                } else if (entry.action === 'CLEAR_PORTFOLIO') {
                    row += `"${entry.portfolioSize} assets",,,,`;
                } else if (entry.action === 'QUANTITY_CHANGE') {
                    row += `"${entry.displayAsset}",`;
                    row += `"${entry.oldQuantity} â†’ ${entry.newQuantity}",,,"${entry.source || 'hyperliquid'}"`;
                } else {
                    row += `"${entry.displayAsset}",`;
                    row += `"${entry.quantity}",`;
                    row += `"${entry.price}",`;
                    row += `"${entry.value}",`;
                    row += `"${entry.source || 'hyperliquid'}"`;
                }
                
                csvContent += row + '\n';
            });
            
            // Create download link
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `portfolio_history_${new Date().toISOString().slice(0, 10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showMessage('History downloaded as CSV', 'success');
        }

        // Show message to user
        function showMessage(message, type) {
            const messagesDiv = document.getElementById('messages');
            const messageElement = document.createElement('div');
            messageElement.className = type;
            messageElement.textContent = message;
            messagesDiv.appendChild(messageElement);
            
            // Auto-remove message after 5 seconds
            setTimeout(() => {
                messagesDiv.removeChild(messageElement);
            }, 5000);
        }
    </script>
</body>
</html>
